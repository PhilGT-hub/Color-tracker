<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multi-Color Tracker</title>
<style>
  body { font-family: sans-serif; text-align: center; background: #f0f0f0; padding: 20px; }
  video, canvas { border: 1px solid #333; margin-top: 10px; }
  #crosshair {
    position: absolute;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    pointer-events: none;
    border-left: 1px solid red;
    border-top: 1px solid red;
    border-right: 1px solid red;
    border-bottom: 1px solid red;
  }
  #controls { margin: 10px; }
  .picker-container { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
  .picker-item { display: flex; align-items: center; gap: 5px; }
</style>
</head>
<body>
<h1>Multi-Color Crosshair Tracker</h1>
<div id="instructions">Drag the crosshair over the video and click to add a color to track (exact RGB match).</div>

<div id="controls">
  <button id="addPickerBtn">Add Color Picker</button>
</div>
<div class="picker-container" id="pickerContainer"></div>

<video id="video" autoplay playsinline width="320" height="240"></video>
<canvas id="canvas" width="320" height="240"></canvas>
<div id="crosshair"></div>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const crosshair = document.getElementById('crosshair');
const pickerContainer = document.getElementById('pickerContainer');
let canvasRect = null;

// Array of colors to track
let trackedColors = [];

// Access webcam
navigator.mediaDevices.getUserMedia({ video: true })
  .then(stream => { video.srcObject = stream; })
  .catch(err => { alert('Error accessing webcam: ' + err); });

// Update crosshair position
document.addEventListener('mousemove', (e) => {
    crosshair.style.left = e.clientX + "px";
    crosshair.style.top = e.clientY + "px";
});

// Add a color picker dynamically
document.getElementById('addPickerBtn').addEventListener('click', () => {
    const pickerDiv = document.createElement('div');
    pickerDiv.className = 'picker-item';
    const input = document.createElement('input');
    input.type = 'color';
    input.value = '#ff0000';
    pickerDiv.appendChild(input);
    const label = document.createElement('span');
    label.textContent = 'Pick';
    pickerDiv.appendChild(label);
    pickerContainer.appendChild(pickerDiv);
    trackedColors.push({color: [255,0,0], element: input}); // default red

    input.addEventListener('input', () => {
        trackedColors.forEach(tc => {
            if(tc.element === input) {
                tc.color = hexToRgb(input.value);
            }
        });
    });
});

// Pick color under crosshair
canvas.addEventListener('click', (e) => {
    if (!canvasRect) canvasRect = canvas.getBoundingClientRect();
    const x = Math.floor(e.clientX - canvasRect.left);
    const y = Math.floor(e.clientY - canvasRect.top);
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return;

    const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const idx = (y * canvas.width + x) * 4;
    const pickedColor = [frame.data[idx], frame.data[idx+1], frame.data[idx+2]];

    // Add new tracked color
    const pickerDiv = document.createElement('div');
    pickerDiv.className = 'picker-item';
    const input = document.createElement('input');
    input.type = 'color';
    input.value = rgbToHex(...pickedColor);
    pickerDiv.appendChild(input);
    const label = document.createElement('span');
    label.textContent = 'Picked';
    pickerDiv.appendChild(label);
    pickerContainer.appendChild(pickerDiv);

    trackedColors.push({color: pickedColor, element: input});

    input.addEventListener('input', () => {
        trackedColors.forEach(tc => {
            if(tc.element === input) {
                tc.color = hexToRgb(input.value);
            }
        });
    });
});

// Process video frames
function processFrame() {
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = frame.data;

    trackedColors.forEach(tc => {
        let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
        let found = false;
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const i = (y * canvas.width + x) * 4;
                const r = data[i], g = data[i+1], b = data[i+2];
                if(r === tc.color[0] && g === tc.color[1] && b === tc.color[2]) {
                    found = true;
                    if(x < minX) minX = x;
                    if(y < minY) minY = y;
                    if(x > maxX) maxX = x;
                    if(y > maxY) maxY = y;
                }
            }
        }
        if(found) {
            ctx.strokeStyle = rgbToHex(...tc.color);
            ctx.lineWidth = 2;
            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
        }
    });

    requestAnimationFrame(processFrame);
}

video.addEventListener('play', () => { 
    canvasRect = canvas.getBoundingClientRect();
    processFrame(); 
});

// Helpers
function hexToRgb(hex) {
    hex = hex.replace('#','');
    return [parseInt(hex.substr(0,2),16), parseInt(hex.substr(2,2),16), parseInt(hex.substr(4,2),16)];
}
function rgbToHex(r,g,b){
    return "#" + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
}
</script>
</body>
</html>
