<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Object Tracker with Drawing</title>
<style>
  body { font-family: sans-serif; text-align: center; background: #f0f0f0; padding: 20px; }
  video, canvas { border: 1px solid #333; margin-top: 10px; touch-action: none; }
  #controls { margin: 10px; }
</style>
</head>
<body>
<h1>Object Tracker with Drawing</h1>
<div id="controls">
  <button id="screenshotBtn">Screen Shot</button>
  <button id="applyBtn">Apply Tracking</button>
  <button id="flipBtn">Flip Camera</button>
</div>

<video id="video" autoplay playsinline width="320" height="240"></video>
<canvas id="canvas" width="320" height="240"></canvas>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let templateData = null;
let templateRect = null;
let isSelecting = false;
let startX = 0, startY = 0;
let currentFacingMode = "environment"; // start with back camera
let stream = null;

// Start camera with facingMode
async function startCamera(facingMode){
    if(stream) stream.getTracks().forEach(track => track.stop());
    try{
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode } });
        video.srcObject = stream;
    }catch(err){ alert("Camera error: "+err); }
}
startCamera(currentFacingMode);

// Screenshot
document.getElementById('screenshotBtn').addEventListener('click', () => {
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    templateData = ctx.getImageData(0,0,canvas.width,canvas.height);
    templateRect = null;
});

// Flip camera
document.getElementById('flipBtn').addEventListener('click', () => {
    currentFacingMode = currentFacingMode==="environment"?"user":"environment";
    startCamera(currentFacingMode);
});

// Handle mouse + touch events
function getPos(e){
    const rect = canvas.getBoundingClientRect();
    let clientX = e.clientX, clientY = e.clientY;
    if(e.touches){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    return { x: clientX - rect.left, y: clientY - rect.top };
}

canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('touchstart', startDraw);
canvas.addEventListener('mousemove', drawRect);
canvas.addEventListener('touchmove', drawRect);
canvas.addEventListener('mouseup', endDraw);
canvas.addEventListener('touchend', endDraw);

function startDraw(e){
    if(!templateData) return;
    isSelecting = true;
    const pos = getPos(e);
    startX = pos.x; startY = pos.y;
}

function drawRect(e){
    if(!isSelecting || !templateData) return;
    const pos = getPos(e);
    const w = pos.x - startX;
    const h = pos.y - startY;
    ctx.putImageData(templateData,0,0); // redraw screenshot
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.strokeRect(startX,startY,w,h);
    e.preventDefault();
}

function endDraw(e){
    if(!isSelecting || !templateData) return;
    const pos = getPos(e);
    templateRect = {
        x: Math.min(startX,pos.x),
        y: Math.min(startY,pos.y),
        w: Math.abs(pos.x - startX),
        h: Math.abs(pos.y - startY)
    };
    isSelecting = false;
}

// Apply template tracking
function applyTracking() {
    if(!templateRect){ alert('Draw a rectangle first'); return; }
    const t = ctx.getImageData(templateRect.x, templateRect.y, templateRect.w, templateRect.h);

    function matchFrame(){
        ctx.drawImage(video,0,0,canvas.width,canvas.height);
        const frame = ctx.getImageData(0,0,canvas.width,canvas.height);
        let bestDiff = Infinity;
        let bestX=0, bestY=0;

        for(let y=0; y <= frame.height - t.height; y+=2){
            for(let x=0; x <= frame.width - t.width; x+=2){
                let diff = 0;
                for(let ty=0; ty<t.height; ty+=2){
                    for(let tx=0; tx<t.width; tx+=2){
                        const fi = ((y+ty)*frame.width + (x+tx))*4;
                        const ti = (ty*t.width + tx)*4;
                        diff += Math.abs(frame.data[fi]-t.data[ti]);
                        diff += Math.abs(frame.data[fi+1]-t.data[ti+1]);
                        diff += Math.abs(frame.data[fi+2]-t.data[ti+2]);
                    }
                }
                if(diff < bestDiff){
                    bestDiff = diff;
                    bestX = x;
                    bestY = y;
                }
            }
        }

        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.strokeRect(bestX,bestY,t.width,t.height);

        requestAnimationFrame(matchFrame);
    }
    matchFrame();
}

document.getElementById('applyBtn').addEventListener('click', applyTracking);
</script>
</body>
</html>
